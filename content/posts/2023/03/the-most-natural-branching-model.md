---
title: "The Most Natural Branching Model"
date: 2023-03-08T16:27:55+01:00
keywords: "version control, Git, branching, GitFlow, trunk-based"
categories: [code]
comments: true
---

This is about an argument I‚Äôve had several times in my professional life as a software developer. To my mind the topic is pretty basic, _no_ <i>rocket science</i> at all[^no-rocket-science]. It‚Äôs about [branching in version control](<https://en.wikipedia.org/wiki/Branching_(version_control)>). And there‚Äôs plenty of articles and documentation out there discussing that basic topic and describing best practices.[^sources] So, I won‚Äôt make any claim that I could add essential new thoughts to it. But since that discussion keeps popping up every now and then I‚Äôll write down my take on it and some observations and learnings just for later reference. And also because many of the results of a web search for <i>‚Äúbest branching strategy‚Äù</i>[^biased-search] are nothing but marketing filling material articles that try to be all too neutral or just mirror some ideas collected from their own web search. In their superficiality I haven‚Äôt found them helpful for decision making in a team. In contrast, this one‚Äôs gonna be opinionated and based on my own experience and learnings from the past decade.

[^no-rocket-science]: Darn it! I‚Äôll probably never write about rocket science.
[^sources]: Sources I recommend:

    - the [article introducing GitFlow](https://nvie.com/posts/a-successful-git-branching-model/)
    - an early [article criticizing GitFlow](https://barro.github.io/2016/02/a-succesful-git-branching-model-considered-harmful/)
    - a popular [documentation portal on Trunk-based Development](https://trunkbaseddevelopment.com/)
    - Dave Farley explaining [why GitFlow is a bad idea](https://youtu.be/_w6TwnLCFwA)

[^biased-search]: Well, search strings starting with ‚Äúbest‚Äù are prone to bring up pretentious results, aren‚Äôt they?

**TL;DR:** <i>GitFlow</i>, though having gained notable popularity, came with substantial design flaws, but at least it mad[](https://youtu.be/_w6TwnLCFwA)e people come up with names for the nothing new but most natural branching model: <i>The Cactus Model</i> or <i>Trunk-based Development</i>.

## Who needs parallel history?

So, you have heard about <i>GitFlow</i>. Sure, you have. It was very popular about ten years ago. And that was probably because it was very well thought-through and documented, really nicely presented in [a well-written article](https://nvie.com/posts/a-successful-git-branching-model/), and first and foremost, it came with a set of clear rules. And people long for clear rules, especially tech people like us, don‚Äôt we? So, before I go into any criticism, I want to make clear that I really appreciate that model having been shared with the community. Making our ideas a common good instead of keeping them enclosed in the silos of our brains makes us move forward and grow together.

Anyway, here‚Äôs my bold statement: <b title="I‚Äôm a <b> element used for boldness. Not quite appropriate but funny, isn‚Äôt it?">Alternate-history branches are bad üò±.</b> If your branching model involves two or more permanent branches meant to be _merged back and forth_[^3] think twice whether it‚Äôs really worth the hassle.

Okay, it‚Äôs not like this kind of branching and merging is bad in the sense of killing kittens or inevitably ruining your team‚Äôs productivity. It‚Äôs just that it‚Äôs extra complexity added to your version control. And tech people like us want extra complexity to be be well-founded or avoided, don‚Äôt we? So, before settling on GitFlow or some derivative you should really ask yourself why you would want multiple branches telling parallel, divergent versions of code history[^4]? At long sight, the only timeline that matters is the one documenting **what changes** were made to the **main branch** in **which order**.

[^3]: The coupling of the two branches is important here. My criticism does not apply to multiple permanent branches that are disjunct by design. Situations where, for example, several diverged versions of a product are maintained on corresponding branches are a different kettle of fish. And so are peculiar branches dedicated to special features of a repository, e. g. <i>gh-pages</i>.
[^4]: I‚Äôm a huge fan of science fiction which implies a fascination of time traveling and alternative timelines. I also like the [many-worlds interpretation](https://en.wikipedia.org/wiki/Many-worlds_interpretation) just for its story-telling potential. But when it comes to writing and, even more, reading code I do not seek exciting stories to be told: I want it clean, dry, sober ‚Äì in all dimensions, including the temporal one.

## Why complex branching doesn‚Äôt make sense

Now, before I go ahead and talk about the obvious alternative I want to point out what appear to be the core assumptions that led to the belief that multiple parallel branches are a good idea.

### Branching ‚â† Deployment

I often hear developers argue for two parallel branches because they want one for each [deployment environment](https://en.wikipedia.org/wiki/Deployment_environment). The underlying common misconception seems to be that automated [continuous deployment](https://en.wikipedia.org/wiki/Continuous_deployment) can only happen from a _permanent_ branch that perfectly _mirrors_ the deployment history. That‚Äôs not true.

To deploy a version-controlled codebase, essentially, you need a way to specify the commit that you intend to deploy at any time. While the most immediate way would be to just pass the respective commit hash to some deployment command, you‚Äôll probably don‚Äôt want that as it doesn‚Äôt allow for automatic deployments triggered by plain commit events. What you‚Äôd rather want is some symbolic name on your version control that your CD can watch for. This is where branches come in handy, because [branches are nothing but symbolic names for commits](https://github.blog/2020-12-17-commits-are-snapshots-not-diffs/#branches-are-pointers). Yes, it‚Äôs perfectly fine to rely on branches to point to the respective commits for your automatic deployments. But apart from acting as named pointers there‚Äôs nothing that branches do for you with regards to automatic deployment. Especially, there is no use in mirroring deployment history.[^history-matters]

[^history-matters]: I‚Äôve heard people argue that they want to see the history of commits as they have been deployed. Well, first of all, code history is actually [linked in the commit](https://github.blog/2020-12-17-commits-are-snapshots-not-diffs/#commits-are-snapshots) itself, not [in a branch](https://github.blog/2020-12-17-commits-are-snapshots-not-diffs/#branches-are-pointers). Second, code history matters at development time, not at deployment time where the code state of interest is in the one of the given commit, not any of its anccestor commits. But the main point here is that deployment history and code history are two distinct things. Why bloat your version control with branches that only exist to tell deployment history? Instead, just maintain a log of commit hashes and deploy timestamps outside of your version control (somewhere connected to your deployment target) and you have exactly what you need and keep different sets of information separated and where they belong.

### No urge to merge

A common companion to the idea of having parallel branches to tell certain kinds of history is that those branches from time to time have to be [‚Äúsynchronized‚Äù by merging them](https://nvie.com/posts/a-successful-git-branching-model/#the-main-branches). And not only those permanent ones but also all kinds of side branches, like [feature branches](https://nvie.com/posts/a-successful-git-branching-model/#incorporating-a-finished-feature-on-develop), [release branches](https://nvie.com/posts/a-successful-git-branching-model/#finishing-a-release-branch), or [hotfix branches](https://nvie.com/posts/a-successful-git-branching-model/#finishing-a-hotfix-branch).

While it‚Äôs obvious why you want to keep side branches up to date with the main branch, it‚Äôs quite questionable why _everything_ happening on some side branch should need to go back into the main branch, even including the history of that side branch. My take on this is to be really relaxed about side branches and their history and only care about the main branch. As I said above this is where all relevant code history is written, whereas side branches only exist for one single temporary purpose and hence, are perfectly fine to stay open-ended or even be cut out, eventually. However, there should never the need arise to [merge](https://book.git-scm.com/docs/gitglossary#def_merge) (as in, non fast-forward merge) them back into the main branch. Let‚Äôs prove this for the three common types of side branches mentioned above:

Feature branch
:   This is a branch owned by one developer (or small team) working on a specific feature. Its main purpose is to be able to implement that feature without getting distracted by concurrent changes to the codebase and without having to commit intermediary states to the the main branch. Only when the feature is ready all its related code changes go to the main branch at once. At that moment it doesn‚Äôt really matter[^feature-history-details] when and on which base the original commits were made. If our goal is to keep the history free from irrelevant information then the cleanest way of merging a feature branch to the main branch is [rebasing](https://book.git-scm.com/docs/gitglossary#def_rebase) the latter onto the former and [fast-forwarding](https://book.git-scm.com/docs/gitglossary#def_fast_forward) the former to the rebased head (a. k. a. ‚Äúrebase-merge‚Äù).[^personal-preference]

[^feature-history-details]: Maybe it does matter to the commits‚Äô author for some nostalgic reason, but to the whole team or other consumers of the code history (e. g. the public) it doesn‚Äôt.
[^personal-preference]: How you actually merge your feature branch remains of course a [matter of taste](https://trunkbaseddevelopment.com/short-lived-feature-branches/#personal-preferences). You might be convinced of the [fast-forward-only approach](https://barro.github.io/2016/02/a-succesful-git-branching-model-considered-harmful/#there-are-only-fast-forward-merges). But you might as well [insist in keeping feature development details by enforcing merge commits](https://nvie.com/posts/a-successful-git-branching-model/#incorporating-a-finished-feature-on-develop). Beware, though, that merge commits are not the only way to preserve those details: Even after [squash-merging a pull request](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/about-pull-request-merges#squash-and-merge-your-commits) and [deleting the feature branch](https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-branches-in-your-repository/deleting-and-restoring-branches-in-a-pull-request#deleting-a-branch-used-for-a-pull-request) the [original commits remain accessible](https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-branches-in-your-repository/deleting-and-restoring-branches-in-a-pull-request#restoring-a-deleted-branch) (depending on some platform features).

Release branch
:   This branch is meant to point to a commit to be deployed to a given target or released as a package at a well-defined version. It‚Äôs not meant to receive any active development. The only changes that are acceptable as well as expectable on release branches are hotfixes. And those do not need to be merged back to the main branch. Instead they should be applied there _independently_. There are [some best practices](https://trunkbaseddevelopment.com/branch-for-release/#fix-production-bugs-on-trunk) regarding a well-defined procedure for applying hotfixes by [cherry-picking](https://book.git-scm.com/docs/gitglossary#def_cherry-picking). But the important idea is that the main and the release branch are fixed by different commits ([cherry-picks are actually less special](https://github.blog/2020-12-17-commits-are-snapshots-not-diffs/#if-commits-arent-diffs-then-what-does-git-cherry-pick-do) than many people think).

Hotfix branch
:   This is either branched off of the main branch and then used for ‚Äúa hotfix release‚Äù, making it effectively just a special case of release branch. Or it‚Äôs branched off of a release branch to work on a hotfix and then merge it back to that release branch. It all boils down to making hotfix commits to releases. Therefore the above also applies to this kind of side branch.

## Keep It Linear, Lovely!

It might not always be true, but in this case <abbr title="Keep It Linear, Lovely!">K.I.L.L.</abbr>[^my-invention] is a special case of [<abbr title="Keep It Simple, Stupid!">K.I.S.S.</abbr>](https://en.wikipedia.org/wiki/KISS_principle). As I pointed out above complex branching models are oftentimes less helpful than they were supposed to be. Instead, in most common cases it‚Äôs perfectly sufficient to stick with a much simpler branching model with just one main branch and only temporary side branches. While [this idea has been nothing special for several decades](https://trunkbaseddevelopment.com/#history) it became the recommended alternative to GitFlow when people realized that the latter is rather getting in their way. It has since been referred to as <i>Trunk-based Development</i> with [trunkbaseddevelopment.com](https://trunkbaseddevelopment.com/) having become the go-to information source.

I just love it for its simplicity and its similarity to nature[^appeal-to-nature]. Instead of having [a Git graph full of merge commits](https://stackoverflow.com/questions/14023648/why-does-my-git-history-look-like-a-christmas-tree) we can just let it grow like a natural tree with one trunk and several branches that grow from it but never back.[^dag-vs-tree]

[^my-invention]: I think, I invented it. üò§
[^appeal-to-nature]: Although, I know that [appeal to nature](https://en.wikipedia.org/wiki/Appeal_to_nature) is not a valid reasoning.
[^dag-vs-tree]: Technically, merge commits or actually allowing the commit graph to be a [DAG](https://en.wikipedia.org/wiki/Directed_acyclic_graph) rather than just a (directed) [tree](https://en.wikipedia.org/wiki/Tree_(graph_theory)) is a great feature of Git. And there are valid use cases, for sure. But in many day-to-day situations merge commits are rather bloat to your history that could be prevented with a little care.